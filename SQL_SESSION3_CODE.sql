JOIN IN SQL:
	TWO TYPS OF SQL JOIN:
	1.VERTICAL JOIN(APPENDING TABLES)
		SOURCE TABLE
		TARGET TABLE:
			1.EQUAL NUMBER OF FIELDS
			2.SAME DATA TYPES
		TWO TYPES:
		1.UNION ALL: DUPLICATE RECORDS
		2.UNION : UNIQUE RECORDS
	2.HORIZONTAL JOIN
		LEFT TABLE
		RIGHT TABLE
			STEPS:
			1.IDENTIFY THE TABLES(LEFT TABLE AND RIGHT TABLE)
			2.IDENTIFY THE COMMON FIELD
			3.IDENTIFY THE COMMON AND UNCOMMON RECORDS
		DIFFERENT TYPES:
		1.INNER JOIN: COMMON RECORDS FROM BOTH TABLE
		2.OUTER JOIN:
			1.FULL OUTER JOIN: TAKES ALL COMMON AND UNCOMMON RECORDS FROM BOTH TABLE
			2.UNMATCHED JOIN: TAKES THE UNCOMMON RECORDS FROM BOTH TABLE
			3.LEFT OUTER JOIN/LEFT JOIN: TAKES ALL RECORDS FROM LEFT TABLE AND COMMON RECORDS FROM RIGHT TABLE
			4.LEFT NULL JOIN: TAKES THE UNCOMMON RECORDS FROM LEFT TABLE
			5.RIGHT JOIN/RIGHT OUTER JOIN: TAKES ALL RECORDS FROM RIGHT TABLE AND COMMON RECORDS FROM LDFT TABLE
			6.RIGHT NULL JOIN: TAKES UNCOMMON RECORDS FROM RIGHT TABLE

SCENARIO1:

SELECT * FROM MED_APPOLO;
SELECT * FROM MED_CIPLA;
SELECT * FROM MED_GENO;

1.UNION ALL

SELECT * FROM MED_APPOLO
UNION ALL
SELECT * FROM MED_CIPLA
UNION ALL
SELECT * FROM MED_GENO;

SELECT * INTO MED_APPOLO_CIPLA_GENO  FROM MED_APPOLO
UNION ALL
SELECT * FROM MED_CIPLA
UNION ALL
SELECT * FROM MED_GENO;

SELECT * FROM MED_APPOLO_CIPLA_GENO;

SCENARIO2:

SELECT * FROM MED_APPOLO;
SELECT * FROM MED_CIPLA;
SELECT * FROM MED_GENO;
SELECT * FROM MED_RELEGARE;

SELECT * FROM MED_APPOLO
UNION ALL
SELECT * FROM MED_CIPLA
UNION ALL
SELECT * FROM MED_GENO
UNION ALL
SELECT * FROM MED_RELEGARE;

SQL HAS COGNITIVE APPROACH BY WHICH THE RELATED FIELDS ARE IDENTIFIED
VISITS: NO_OF_TRIPS

SCENARIO3:

SELECT * FROM MED_APPOLO;
SELECT * FROM MED_GSK;

SELECT * FROM MED_APPOLO
UNION ALL
SELECT * FROM MED_GSK;

All queries combined using a UNION, INTERSECT or 
EXCEPT operator must have an equal number of expressions in their target lists.

VERTICAL TYPES:
1.UNION ALL
2.UNION

SELECT * FROM STU_SCORE_DATA1;
SELECT * FROM STU_SCORE_DATA2;

1.UNION ALL: 22 RECORDS(DUPLICATE RECORDS)

SELECT * FROM STU_SCORE_DATA1
UNION ALL
SELECT * FROM STU_SCORE_DATA2;

2.UNION: 19 RECORDS( UNIQUE RECORDS: 22-3=19 RECORDS)

SELECT * FROM STU_SCORE_DATA1
UNION 
SELECT * FROM STU_SCORE_DATA2;

UNION ALL: QUERY APPENDS RECORDS IRRESPECTIVE OF DUPLICATE RECORDS
UNION: APPENDS RECORDS WITH ONLY UNIQUE VALUE

2.HORIZONTAL JOIN:

SELECT * FROM EMP_DETAILS;
SELECT * FROM EMP_EXP;

STEPS:
	1.IDENTIFY THE TABLES
		LEFT TABLE:EMP_DETAILS AS A
		RIGHT TABLE:EMP_EXP AS B
	2.IDENTIFY THE COMMON FIELD
		LEFT TABLE:EMP_DETAILS: EMP_ID
		RIGHT TABLE:EMP_EXP:EMP_ID

1.INNER JOIN

SELECT
A.EMP_ID,
A.COMPANY,
A.GENDER,
A.AGE,
A.STATE_CODE,
B.EMP_ID,
B.DEPARTMENT,
B.EDUCATION,
B.EXPERIENCE,
B.SALARY
FROM EMP_DETAILS AS A
INNER JOIN
EMP_EXP AS B
ON A.EMP_ID=B.EMP_ID;

2.FULL JOIN

SELECT
A.EMP_ID,
A.COMPANY,
A.GENDER,
A.AGE,
A.STATE_CODE,
B.EMP_ID,
B.DEPARTMENT,
B.EDUCATION,
B.EXPERIENCE,
B.SALARY
FROM EMP_DETAILS AS A
FULL JOIN
EMP_EXP AS B
ON A.EMP_ID=B.EMP_ID;

3.UNMATCHED JOIN

SELECT
A.EMP_ID,
A.COMPANY,
A.GENDER,
A.AGE,
A.STATE_CODE,
B.EMP_ID,
B.DEPARTMENT,
B.EDUCATION,
B.EXPERIENCE,
B.SALARY
FROM EMP_DETAILS AS A
FULL JOIN
EMP_EXP AS B
ON A.EMP_ID=B.EMP_ID
WHERE A.EMP_ID IS NULL OR B.EMP_ID IS NULL;

4.LEFT JOIN

SELECT
A.EMP_ID,
A.COMPANY,
A.GENDER,
A.AGE,
A.STATE_CODE,
B.EMP_ID,
B.DEPARTMENT,
B.EDUCATION,
B.EXPERIENCE,
B.SALARY
FROM EMP_DETAILS AS A
LEFT JOIN
EMP_EXP AS B
ON A.EMP_ID=B.EMP_ID;

5.LEFT NULL JOIN

SELECT
A.EMP_ID,
A.COMPANY,
A.GENDER,
A.AGE,
A.STATE_CODE,
B.EMP_ID,
B.DEPARTMENT,
B.EDUCATION,
B.EXPERIENCE,
B.SALARY
FROM EMP_DETAILS AS A
LEFT JOIN
EMP_EXP AS B
ON A.EMP_ID=B.EMP_ID
WHERE B.EMP_ID IS NULL;

6.RIGHT JOIN

SELECT
A.EMP_ID,
A.COMPANY,
A.GENDER,
A.AGE,
A.STATE_CODE,
B.EMP_ID,
B.DEPARTMENT,
B.EDUCATION,
B.EXPERIENCE,
B.SALARY
FROM EMP_DETAILS AS A
RIGHT JOIN
EMP_EXP AS B
ON A.EMP_ID=B.EMP_ID;

6.RIGHT NULL JOIN:

SELECT
A.EMP_ID,
A.COMPANY,
A.GENDER,
A.AGE,
A.STATE_CODE,
B.EMP_ID,
B.DEPARTMENT,
B.EDUCATION,
B.EXPERIENCE,
B.SALARY
FROM EMP_DETAILS AS A
RIGHT JOIN
EMP_EXP AS B
ON A.EMP_ID=B.EMP_ID
WHERE A.EMP_ID IS NULL;

VERTICAL JOIN REAL TIME EXAMPLES:

SELECT * FROM E_BOOKING_TRANSACTION_DATA_Q1;
SELECT * FROM E_BOOKING_TRANSACTION_DATA_Q2;
SELECT * FROM E_BOOKING_TRANSACTION_DATA_Q3;
SELECT * FROM E_BOOKING_TRANSACTION_DATA_Q4;

YEARLY DATA

SELECT * INTO YATRA_YEARLY_DATA FROM E_BOOKING_TRANSACTION_DATA_Q1
UNION ALL
SELECT * FROM E_BOOKING_TRANSACTION_DATA_Q2
UNION ALL
SELECT * FROM E_BOOKING_TRANSACTION_DATA_Q3
UNION ALL
SELECT * FROM E_BOOKING_TRANSACTION_DATA_Q4;

SELECT * FROM YATRA_YEARLY_DATA;

HORIZONTAL JOIN EXAMPLES:

SELECT * FROM BOOKING_MASTER;
SELECT * FROM CUSTOMER_MASTER;

Q1	MERGE BOOKING_DETAILS AND CUSTOMER_MASTER FILE

STEP 1: IDENTIFY THE TABLES
	LEFT TABLE: BOOKING_MASTER AS A
	RIGHT TABLE:CUSTOMER_MASTER AS B

STEP 2: IDENTIFY THE COMMON FIELD
	LEFT TABLE: BOOKING_MASTER-CUSTOMER_ID
	RIGHT TABLE:CUSTOMER_MASTER-CUSTOMER_ID

SELECT
A.ORDER_ID,
A.CUSTOMER_ID,
B.CUSTOMER_NAME,
B.CUSTOMER_TYPE,
B.DOB,
B.EMAIL_ID,
A.BOOKING_DATE,
A.NO_OF_TRAVELLERS,
A.FLIGHT_NAME,
A.FLIGHT_FARE,
A.PAYMENT_MODE,
A.[PAYMENT STATUS] AS PAYMENT_STATUS
FROM BOOKING_MASTER AS A
LEFT JOIN
CUSTOMER_MASTER AS B
ON A.CUSTOMER_ID=B.CUSTOMER_ID;

Q2	FIND CUSTOMER WHOSE PERSONAL INFORMATION IS MISSING

SELECT
A.ORDER_ID,
A.CUSTOMER_ID,
B.CUSTOMER_NAME,
B.CUSTOMER_TYPE,
B.DOB,
B.EMAIL_ID,
A.BOOKING_DATE,
A.NO_OF_TRAVELLERS,
A.FLIGHT_NAME,
A.FLIGHT_FARE,
A.PAYMENT_MODE,
A.[PAYMENT STATUS] AS PAYMENT_STATUS
FROM BOOKING_MASTER AS A
LEFT JOIN
CUSTOMER_MASTER AS B
ON A.CUSTOMER_ID=B.CUSTOMER_ID
WHERE B.CUSTOMER_ID IS NULL;

Q3	GET CUSTOMER DETAILS WHOSE PAYMENT_STATUS IS NO AND THEY ARE FROM HSBC CC HOLDER.GET THEIR NAME,DOB AND EMAIL ADDRESS

ANS:
SELECT
A.CUSTOMER_ID,
B.CUSTOMER_NAME,
B.CUSTOMER_TYPE,
B.DOB,
B.EMAIL_ID
FROM BOOKING_MASTER AS A
LEFT JOIN
CUSTOMER_MASTER AS B
ON A.CUSTOMER_ID=B.CUSTOMER_ID
WHERE A.[PAYMENT STATUS]='NO' AND 
A.PAYMENT_MODE='HSBC CC';

Q4	FIND CUSTOMER WHO TRAVELS IN AIR INDIA AND THEIR FULL DETAILS

SELECT
A.ORDER_ID,
A.CUSTOMER_ID,
B.CUSTOMER_NAME,
B.CUSTOMER_TYPE,
B.DOB,
B.EMAIL_ID,
A.BOOKING_DATE,
A.NO_OF_TRAVELLERS,
A.FLIGHT_NAME,
A.FLIGHT_FARE,
A.PAYMENT_MODE,
A.[PAYMENT STATUS] AS PAYMENT_STATUS
FROM BOOKING_MASTER AS A
LEFT JOIN
CUSTOMER_MASTER AS B
ON A.CUSTOMER_ID=B.CUSTOMER_ID
WHERE A.[PAYMENT STATUS]='YES' AND 
A.FLIGHT_NAME='AIR INDIA';

3.INTERSECT AND EXCEPT JOIN

SELECT STATEMENT1
INTERSECT
SELECT STATEMENT2

SELECT STATEMENT1
EXCEPT
SELECT STATEMENT2

TO COMBINE TWO SELECT STATEMENTS TO GET A SINGLE RESULT SET:

SELECT * FROM STU_EDU;
SELECT * FROM STU_EXP;

INTERSECT: OPERATOR RETURNS ALL RECORDS IN BOTH THE TABLES(INNER JOIN RECORDS)

RIGHT JOIN
INTERSECT
LEFT JOIN: INNER JOIN

SELECT 
A.STU_ID,
A.STU_NAME,
A.GENDER,
A.EDUCATION,
B.STU_ID,
B.YOE,
B.COMPANY,
B.SALARY
FROM STU_EDU AS A
RIGHT JOIN
STU_EXP AS B
ON A.STU_ID=B.STU_ID
INTERSECT
SELECT 
A.STU_ID,
A.STU_NAME,
A.GENDER,
A.EDUCATION,
B.STU_ID,
B.YOE,
B.COMPANY,
B.SALARY
FROM STU_EDU AS A
LEFT JOIN
STU_EXP AS B
ON A.STU_ID=B.STU_ID;

LEFT JOIN
INTERSECT
RIGHT JOIN: INNER JOIN

SELECT 
A.STU_ID,
A.STU_NAME,
A.GENDER,
A.EDUCATION,
B.STU_ID,
B.YOE,
B.COMPANY,
B.SALARY
FROM STU_EDU AS A
LEFT JOIN
STU_EXP AS B
ON A.STU_ID=B.STU_ID
INTERSECT
SELECT 
A.STU_ID,
A.STU_NAME,
A.GENDER,
A.EDUCATION,
B.STU_ID,
B.YOE,
B.COMPANY,
B.SALARY
FROM STU_EDU AS A
RIGHT JOIN
STU_EXP AS B
ON A.STU_ID=B.STU_ID;

EXCEPT: OPERATOR RETIRNS THE RECORDS THAT ARE PRESENT IN FIRST SET AND NOT IN SECOND SET

CASE1:

RIGHT JOIN
EXCEPT
LEFT JOIN: RIGHT NULL 

SELECT 
A.STU_ID,
A.STU_NAME,
A.GENDER,
A.EDUCATION,
B.STU_ID,
B.YOE,
B.COMPANY,
B.SALARY
FROM STU_EDU AS A
RIGHT JOIN
STU_EXP AS B
ON A.STU_ID=B.STU_ID
EXCEPT
SELECT 
A.STU_ID,
A.STU_NAME,
A.GENDER,
A.EDUCATION,
B.STU_ID,
B.YOE,
B.COMPANY,
B.SALARY
FROM STU_EDU AS A
LEFT JOIN
STU_EXP AS B
ON A.STU_ID=B.STU_ID;

LEFT JOIN
EXCEPT
RIGHT JOIN: LEFT NULL

SELECT 
A.STU_ID,
A.STU_NAME,
A.GENDER,
A.EDUCATION,
B.STU_ID,
B.YOE,
B.COMPANY,
B.SALARY
FROM STU_EDU AS A
LEFT JOIN
STU_EXP AS B
ON A.STU_ID=B.STU_ID
EXCEPT
SELECT 
A.STU_ID,
A.STU_NAME,
A.GENDER,
A.EDUCATION,
B.STU_ID,
B.YOE,
B.COMPANY,
B.SALARY
FROM STU_EDU AS A
RIGHT JOIN
STU_EXP AS B
ON A.STU_ID=B.STU_ID;

Q. IMAGINE INNER JOIN NOT WORKING, 
HOW TO GET INNER JOIN?

ANS:
1.USE INTERSECT
2.FULL JOIN
3.LEFT JOIN
4.RIGHT JOIN

2.FULL JOIN

SELECT 
A.STU_ID,
A.STU_NAME,
A.GENDER,
A.EDUCATION,
B.STU_ID,
B.YOE,
B.COMPANY,
B.SALARY
FROM STU_EDU AS A
FULL JOIN
STU_EXP AS B
ON A.STU_ID=B.STU_ID
WHERE A.STU_ID IS NOT NULL AND B.STU_ID IS NOT NULL;

3.LEFT JOIN

SELECT 
A.STU_ID,
A.STU_NAME,
A.GENDER,
A.EDUCATION,
B.STU_ID,
B.YOE,
B.COMPANY,
B.SALARY
FROM STU_EDU AS A
LEFT JOIN
STU_EXP AS B
ON A.STU_ID=B.STU_ID
WHERE B.STU_ID IS NOT NULL;

4.RIGHT JOIN

SELECT 
A.STU_ID,
A.STU_NAME,
A.GENDER,
A.EDUCATION,
B.STU_ID,
B.YOE,
B.COMPANY,
B.SALARY
FROM STU_EDU AS A
RIGHT JOIN
STU_EXP AS B
ON A.STU_ID=B.STU_ID
WHERE A.STU_ID IS NOT NULL;

4.MULTICOLUMN JOIN

SELECT * FROM PROD_UNITS;
SELECT * FROM PROD_PRICE;

SELECT
A.PRODUCT,
A.CITY,
A.UNITS,
B.PRODUCT,
B.CITY,
B.PRICE,
(A.UNITS*B.PRICE) AS SALES
FROM PROD_UNITS AS A
FULL JOIN
PROD_PRICE AS B
ON A.PRODUCT=B.PRODUCT
AND
A.CITY=B.CITY;

SELECT
A.PRODUCT,
A.CITY,
A.UNITS,
B.PRODUCT,
B.CITY,
B.PRICE,
(A.UNITS*B.PRICE) AS SALES
FROM PROD_UNITS AS A
LEFT JOIN
PROD_PRICE AS B
ON A.PRODUCT=B.PRODUCT
AND
A.CITY=B.CITY;

SELECT
A.PRODUCT,
A.CITY,
A.UNITS,
B.PRODUCT,
B.CITY,
B.PRICE,
(A.UNITS*B.PRICE) AS SALES
FROM PROD_UNITS AS A
RIGHT JOIN
PROD_PRICE AS B
ON A.PRODUCT=B.PRODUCT
AND
A.CITY=B.CITY;

5.SUB QUERY:
	WHEN WE WRITE ONE SELECT INSIDE ANOTHER SELECT

SELECT * FROM APAC_SALES;

Q:FIND COUNTRYWISE MARKET SHARE?

STEP 1: COPY TABLE

SELECT
A.PRODUCT,
A.COUNTRY,
A.SALES
FROM APAC_SALES AS A;

STEP 2: TOTAL_SALES

SELECT
PRODUCT,
SUM(SALES) AS TOTAL_SALES
FROM APAC_SALES
GROUP BY PRODUCT;

STEP 3:MERGE TABLE

SELECT
A.PRODUCT,
A.COUNTRY,
A.SALES,
B.TOTAL_SALES,
FORMAT((A.SALES/B.TOTAL_SALES),'P2') AS MS
FROM APAC_SALES AS A
LEFT JOIN
	(SELECT
	PRODUCT,
	SUM(SALES) AS TOTAL_SALES
	FROM APAC_SALES
	GROUP BY PRODUCT) AS B
ON A.PRODUCT=B.PRODUCT;

EXAMPLE SUB QUERY:

SELECT 'INDIA' AS COUNTRY, 'APPLE' AS LAPTOP, 54000 UNITS_SOLD INTO INDIA_LAPTOP_SALES
UNION ALL
SELECT 'INDIA' AS COUNTRY, 'DELL' AS LAPTOP, 30000 UNITS_SOLD
UNION ALL
SELECT 'INDIA' AS COUNTRY, 'HP' AS LAPTOP, 70000 UNITS_SOLD
UNION ALL
SELECT 'INDIA' AS COUNTRY, 'ACER' AS LAPTOP, 24000 UNITS_SOLD;

SELECT * FROM INDIA_LAPTOP_SALES;

SELECT
A.COUNTRY,
A.LAPTOP,
A.UNITS_SOLD,
B.TOTAL_UNITS_SOLD,
FORMAT((CAST(A.UNITS_SOLD AS FLOAT)/B.TOTAL_UNITS_SOLD),'P2') AS LAPTOP_MS_INDIA
FROM INDIA_LAPTOP_SALES AS A
LEFT JOIN
	(SELECT
	COUNTRY,
	SUM(UNITS_SOLD) AS TOTAL_UNITS_SOLD
	FROM INDIA_LAPTOP_SALES
	GROUP BY COUNTRY) AS B
ON A.COUNTRY=B.COUNTRY;

CAST FUNCTION IS USED HERE FOR CONVERTING THE UNITS_SOLD DATA TYPE FLOAT

EXAMPLE 3: SUB QUERY

SELECT * FROM APAC_COUNTRY_YEAR_SALES;

Q1.GET PRODUCT AND YEAR WISE MARKETSHARE BY COUNTRY?

STEP 1:

SELECT
A.PRODUCT,
A.YEAR,
A.COUNTRY,
A.UNITS
FROM APAC_COUNTRY_YEAR_SALES AS A;

STEP 2:

SELECT
PRODUCT,
YEAR,
SUM(UNITS) AS TOTAL_UNITS
FROM APAC_COUNTRY_YEAR_SALES
GROUP BY PRODUCT,YEAR;

STEP 3:

SELECT
A.PRODUCT,
A.YEAR,
A.COUNTRY,
A.UNITS,
B.TOTAL_UNITS,
FORMAT((A.UNITS/B.TOTAL_UNITS),'P2') AS COUNTRY_MS
FROM APAC_COUNTRY_YEAR_SALES AS A
LEFT JOIN
	(SELECT
	PRODUCT,
	YEAR,
	SUM(UNITS) AS TOTAL_UNITS
	FROM APAC_COUNTRY_YEAR_SALES
	GROUP BY PRODUCT,YEAR) AS B
ON A.PRODUCT=B.PRODUCT
AND A.YEAR=B.YEAR
ORDER BY 1,2,3;

Q2.GET COUNTRY AND YEAR WISE  MS?

SELECT
A.COUNTRY,
A.YEAR,
A.PRODUCT,
A.UNITS,
B.TOTAL_UNITS,
FORMAT((A.UNITS/B.TOTAL_UNITS),'P2') AS COUNTRY_MS
FROM APAC_COUNTRY_YEAR_SALES AS A
LEFT JOIN
	(SELECT
	COUNTRY,
	YEAR,
	SUM(UNITS) AS TOTAL_UNITS
	FROM  APAC_COUNTRY_YEAR_SALES 
	GROUP BY COUNTRY, YEAR) AS B
ON A.COUNTRY=B.COUNTRY
AND A.YEAR=B.YEAR
ORDER BY 1,2,3;

5.SELF JOIN:
	SELF JOIN IS A REGULAR JOIN, THE TABLE GETS JOINED TO ITSELF
	EACH ROW OF THE TABLE GET COMBINED TO ANOTHER ROW IN THE SAME TABLE OR THE SAME ROW

SELECT * FROM EMP_MANAGER;

SELECT
A.EMP_NAME,
A.EMP_ID,
A.MANAGER_NAME,
A.MANAGER_ID,
B.MANAGER_NAME AS MANAGER_MANAGER_NAME,
B.MANAGER_ID AS MANAGER_MANAGER_ID
FROM EMP_MANAGER AS A
LEFT JOIN
EMP_MANAGER AS B
ON A.MANAGER_ID=B.EMP_ID;

6.CROSS JOIN:

SELECT * FROM STU_DATA;
SELECT * FROM APP_DATA;

SELECT A.*,
B.*
FROM STU_DATA AS A
CROSS JOIN
APP_DATA AS B
ORDER BY 1;

CAN WE JOIN TWO TABLES WITH NO COMMON FIELD IN SQL?
ANS: YES, CROSS JOIN.

7.NULL JOIN:

SELECT * FROM NULL_JOIN_DATA1;
SELECT * FROM NULL_JOIN_DATA2;

SELECT
A.CUSTOMER_ID,
A.COMPANY,
A.GENDER,
A.AGE,
B.CUSTOMER_ID,
B.TOWN,
B.NO_OF_TRIPS,
B.[SPENT AMOUNT] AS SPENT_AMOUNT
FROM NULL_JOIN_DATA1 AS A
INNER JOIN
NULL_JOIN_DATA2 AS B
ON A.CUSTOMER_ID=B.CUSTOMER_ID;

SELECT
A.CUSTOMER_ID,
A.COMPANY,
A.GENDER,
A.AGE,
B.CUSTOMER_ID,
B.TOWN,
B.NO_OF_TRIPS,
B.[SPENT AMOUNT] AS SPENT_AMOUNT
FROM NULL_JOIN_DATA1 AS A
FULL JOIN
NULL_JOIN_DATA2 AS B
ON A.CUSTOMER_ID=B.CUSTOMER_ID;

8.RELATIONSHIP
	1.ONE TO ONE
	2.ONE TO MANY
	3.MANY TO ONE
	4.MANY TO MANY


1.ONE TO ONE

SELECT * FROM PLAYERS_DETAILS;
SELECT * FROM PLAYERS_SCORE;
SELECT * FROM MATCH_SCORE;
SELECT * FROM PLAYERS_SCORE_CONTRIBUTION;
SELECT * FROM SERIES_SCORE;

SELECT * FROM PLAYERS_DETAILS;
SELECT * FROM PLAYERS_SCORE;

SELECT
A.PLAYERS_ID,
A.PLAYERS_NAME,
A.EXPERTIES,
B.PLAYERS_ID,
B.SCORE
FROM PLAYERS_DETAILS AS A
LEFT JOIN
PLAYERS_SCORE AS B
ON A.PLAYERS_ID=B.PLAYERS_ID;

2. ONE TO MANY

SELECT * FROM PLAYERS_DETAILS;
SELECT * FROM MATCH_SCORE;

SELECT
A.PLAYERS_ID,
A.PLAYERS_NAME,
A.EXPERTIES,
B.PLAYERS_ID,
B.SCORE,
B.MATCHES
FROM PLAYERS_DETAILS AS A
LEFT JOIN
MATCH_SCORE AS B
ON A.PLAYERS_ID=B.PLAYERS_ID;

3.MANY TO ONE

SELECT * FROM MATCH_SCORE;
SELECT * FROM PLAYERS_DETAILS;

SELECT
A.PLAYERS_ID,
A.SCORE,
A.MATCHES,
B.PLAYERS_ID,
B.PLAYERS_NAME,
B.EXPERTIES
FROM MATCH_SCORE AS A
RIGHT JOIN
PLAYERS_DETAILS AS B
ON A.PLAYERS_ID=B.PLAYERS_ID;

4.MANY TO MANY

SELECT * FROM SERIES_SCORE;
SELECT * FROM PLAYERS_SCORE_CONTRIBUTION;

SELECT
A.COUNTRY,
A.SERIES,
A.[TOTAL SCORE] AS TOTAL_SCORE,
B.COUNTRY,
B.SCORER,
B.PROPORTION,
(A.[TOTAL SCORE]*B.PROPORTION) AS PLAYER_SCORE
FROM SERIES_SCORE AS A
LEFT JOIN
PLAYERS_SCORE_CONTRIBUTION AS B
ON A.COUNTRY=B.COUNTRY;

DATA MODEL:
	TWO TYPES:
		1.STAR SCHEMA DATA MODEL(FACT TABLE: ONE, DIMENSION_TABLES: MANY)
		2.SNOW FLAKES DATA MODEL

1.STAR SCHEMA DATA MODEL(FACT TABLE: ONE, DIMENSION_TABLES: MANY)

SELECT * FROM TRANSACTION_DM1;
SELECT * FROM CUSTOMER_DM1;
SELECT * FROM PRODUCT_DM1;
SELECT * FROM STORE_DMI;
SELECT * FROM STAFF_DMI;
SELECT * FROM SUPPLIER_DM2;

MERGING TABLES:
	TRANSACTION_DM1 AS A;
	CUSTOMER_DM1 AS B;
	PRODUCT_DM1 AS C;
	STORE_DMI AS D;
	STAFF_DMI AS E;

	RELATIONSHIP: MANY TO ONE
	JOIN: LEFT JOIN
	TRANSACTION_DM1 TO CUSTOMER_DM1 BY CUST_ID;
	TRANSACTION_DM1 TO PRODUCT_DM1 BY PROD_ID;
	TRANSACTION_DM1 TO STORE_DMI BY STORE_ID;
	TRANSACTION_DM1 TO STAFF_DMI BY STAFF_ID;

SELECT
A.ORDER_ID,
A.ORDER_DT,
A.CUST_ID,
B.CUST_NAME,
B.DOB,
B.MOBILE,
A.PROD_ID,
C.PROD_NAME,
C.CATEGORY,
C.PRICE,
C.INVENTORY,
C.SUPPLIER_ID,
A.QTY,
A.STORE_ID,
D.STORE_NAME,
D.LOCATION,
A.STAFF_ID,
E.STAFF_NAME,
E.DESIGNATION,
E.YOE,
(A.QTY*C.PRICE) AS SALES
FROM TRANSACTION_DM1 AS A
LEFT JOIN
CUSTOMER_DM1 AS B ON A.CUST_ID=B.CUST_ID
LEFT JOIN
PRODUCT_DM1 AS C ON A.PROD_ID=C.PROD_ID
LEFT JOIN
STORE_DMI AS D ON A.STORE_ID=D.STORE_ID
LEFT JOIN
STAFF_DMI AS E ON A.STAFF_ID=E.STAFF_ID;

2.SNOW FLAKES DATA MODEL

MERGING TABLES:
	TRANSACTION_DM1 AS A;
	CUSTOMER_DM1 AS B;
	PRODUCT_DM1 AS C;
	STORE_DMI AS D;
	STAFF_DMI AS E;
	SUPPLIER_DM2 AS F;

RELATIONSHIP: MANY TO ONE
	JOIN: LEFT JOIN
	TRANSACTION_DM1 TO CUSTOMER_DM1 BY CUST_ID;
	TRANSACTION_DM1 TO PRODUCT_DM1 BY PROD_ID;
	TRANSACTION_DM1 TO STORE_DMI BY STORE_ID;
	TRANSACTION_DM1 TO STAFF_DMI BY STAFF_ID;
	PRODUCT_DM1 TO SUPPLIER_DM2 BY SUPPLIER_ID;

SELECT
A.ORDER_ID,
A.ORDER_DT,
A.CUST_ID,
B.CUST_NAME,
B.DOB,
B.MOBILE,
A.PROD_ID,
C.PROD_NAME,
C.CATEGORY,
C.PRICE,
C.INVENTORY,
C.SUPPLIER_ID,
F.SUPPLIER_NAME,
F.LOCATION,
A.QTY,
A.STORE_ID,
D.STORE_NAME,
D.LOCATION,
A.STAFF_ID,
E.STAFF_NAME,
E.DESIGNATION,
E.YOE,
(A.QTY*C.PRICE) AS SALES
FROM TRANSACTION_DM1 AS A
LEFT JOIN
CUSTOMER_DM1 AS B ON A.CUST_ID=B.CUST_ID
LEFT JOIN
PRODUCT_DM1 AS C ON A.PROD_ID=C.PROD_ID
LEFT JOIN
STORE_DMI AS D ON A.STORE_ID=D.STORE_ID
LEFT JOIN
STAFF_DMI AS E ON A.STAFF_ID=E.STAFF_ID
LEFT JOIN
SUPPLIER_DM2 AS F ON C.SUPPLIER_ID=F.SUPPLIER_ID;

