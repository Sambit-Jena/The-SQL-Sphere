1. WHAT IS HARD CODED VALUES?
ANS: 

SELECT
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
SPENT_AMOUNT,
GETDATE() AS TODAYS_DATE,
'AUSTARLIA' AS COUNTRY
FROM MED_2023;

2.HOW TO GET TABLE FROM HARD CODED VALUES?

SELECT 'LAKSHMI NR' AS STU_NAME, 35 AS AGE, 'DV2_202310' AS BATCH INTO STU_OCT
UNION ALL
SELECT 'VIVEK' AS STU_NAME, 31 AS AGE, 'DV2_202310' AS BATCH 
UNION ALL
SELECT 'AMISHA' AS STU_NAME, 28 AS AGE, 'DV2_202310' AS BATCH; 

SELECT * FROM STU_OCT;

3. HOW TO SELECT RANDOM RECORDS FROM A ATABLE?
ANS:

SELECT
TOP 100*
FROM MED_2023
ORDER BY NEWID();

4.HOW TO RANK DATA IN SQL ?
ANS:
	1.RANK()
	2.DENSE_RANK()
	3.ROW_NUMBER()

SELECT 'AJAY' AS STU_NAME, 'EXCEL' AS SUBJECT, 45 AS MARKS INTO STU_EXAM
UNION ALL
SELECT 'AJAY' AS STU_NAME, 'SQL' AS SUBJECT, 60 AS MARKS
UNION ALL
SELECT 'AJAY' AS STU_NAME, 'SAS' AS SUBJECT, 60 AS MARKS
UNION ALL
SELECT 'AJAY' AS STU_NAME, 'PYTHON' AS SUBJECT, 80 AS MARKS
UNION ALL
SELECT 'AJAY' AS STU_NAME, 'TABLEAU' AS SUBJECT, 85 AS MARKS
UNION ALL
SELECT 'MEENA' AS STU_NAME, 'EXCEL' AS SUBJECT, 60 AS MARKS 
UNION ALL
SELECT 'MEENA' AS STU_NAME, 'SQL' AS SUBJECT, 67 AS MARKS
UNION ALL
SELECT 'MEENA' AS STU_NAME, 'SAS' AS SUBJECT, 67 AS MARKS
UNION ALL
SELECT 'MEENA' AS STU_NAME, 'PYTHON' AS SUBJECT, 69 AS MARKS
UNION ALL
SELECT 'MEENA' AS STU_NAME, 'TABLEAU' AS SUBJECT, 75 AS MARKS
UNION ALL
SELECT 'GAURI' AS STU_NAME, 'EXCEL' AS SUBJECT, 90 AS MARKS 
UNION ALL
SELECT 'GAURI' AS STU_NAME, 'SQL' AS SUBJECT, 98 AS MARKS
UNION ALL
SELECT 'GAURI' AS STU_NAME, 'SAS' AS SUBJECT, 80 AS MARKS
UNION ALL
SELECT 'GAURI' AS STU_NAME, 'PYTHON' AS SUBJECT, 80 AS MARKS
UNION ALL
SELECT 'GAURI' AS STU_NAME, 'TABLEAU' AS SUBJECT, 79 AS MARKS;

SELECT * FROM STU_EXAM;

SELECT
STU_NAME,
SUBJECT,
MARKS,
RANK() OVER (PARTITION BY STU_NAME ORDER BY MARKS DESC) AS RANKING
FROM STU_EXAM;

DENSE_RANK()

SELECT
STU_NAME,
SUBJECT,
MARKS,
DENSE_RANK() OVER (PARTITION BY STU_NAME ORDER BY MARKS DESC) AS RANKING
FROM STU_EXAM;

DIFFERENCE BETWEEN RANK() AND DENSE_RANK()?
ANS:
	1.BOTH RANK OVER AND DENSE RANK OVER ARE USED FOR RANKING THE ORDER
	2.RANK OVER OMITS THE NEXT HIGHEST CONSECUTIVE RANK WHEN DATA (RECORDS) ARE DUPLICATING
	3.USING DENSE_RANK , PROVIDES THE NEXT HIGHEST CONSECUTIVE RANK EVEN WHEN THE RECORDS ARE DUPLICATE.

RANK() OVER (PARTITION BY STU_NAME ORDER BY MARKS DESC) AS RANKING

OVER() CLAUSE
	1. TO DEFINE A SET OF ROWS IN THE RESULT
	2.TO SORT RESULT IN A DESCENDING(DESC)/ASCENDING(DEFAULT)(ASC)

PARTITION BY
	1.PARTITION BY
	2. DIVIDES THE QUERY RESULT

CASE STUDY ON RANKING:
Q1: GIVEN MED_2023 FIND OUT STATE_CODE, COMPANY, CUSTOMER RANKING( RANKING ORDER IS FROM THE HIGHEST TO LOWEST)

ANS:
STEP 1: SUMMART TABLE: COUNT OF CUSTOMERS

SELECT
STATE_CODE,
COMPANY,
COUNT(CUSTOMER_ID) AS SUBS INTO MED_SUMMARY
FROM MED_2023
GROUP BY STATE_CODE,COMPANY
ORDER BY 1,2;

SELECT * FROM MED_SUMMARY;

STEP 2: RANKING:

SELECT
STATE_CODE,
COMPANY,
SUBS,
DENSE_RANK() OVER(PARTITION BY STATE_CODE ORDER BY SUBS DESC) AS RANKING INTO MED_RANK
FROM MED_SUMMARY;

SELECT * FROM MED_RANK;

USE OF PARTITON BY:
	1.SUMMARIZE DATA BY PARENT TOTAL
	2.CUMMULATIVE SUM BY PARAENTAL TOTAL

SELECT * FROM STU_EXAM;

GET STUDENTS MARKS BY SUBJECT IN %

ANS:
STEP 1:

SELECT
A.STU_NAME,
A.SUBJECT,
A.MARKS
FROM STU_EXAM AS A;

STEP 2:

SELECT
STU_NAME,
SUM(MARKS) AS TOTAL_MARKS
FROM STU_EXAM
GROUP BY STU_NAME;

STEP 3:

SELECT
A.STU_NAME,
A.SUBJECT,
A.MARKS,
B.TOTAL_MARKS,
FORMAT((A.MARKS/CAST(B.TOTAL_MARKS AS FLOAT)),'P0') AS MARKS_PERCENTAGE
FROM STU_EXAM AS A
LEFT JOIN
	(SELECT
	STU_NAME,
	SUM(MARKS) AS TOTAL_MARKS
	FROM STU_EXAM
	GROUP BY STU_NAME) AS B
ON A.STU_NAME=B.STU_NAME;

GET STUDENTS MARKS BY SUBJECT IN %: PARTITION BY

SELECT
STU_NAME,
SUBJECT,
MARKS,
SUM(MARKS) OVER(PARTITION BY STU_NAME ORDER BY STU_NAME) AS TOTAL_MARKS,
FORMAT((CAST(MARKS AS FLOAT)/SUM(MARKS) OVER(PARTITION BY STU_NAME ORDER BY STU_NAME)),'P2') AS MARKS_PERCENTAGE
FROM STU_EXAM
GROUP BY STU_NAME, SUBJECT,MARKS;

CUMMULATIVE SUM:

SELECT
STU_NAME,
SUBJECT,
MARKS,
SUM(MARKS) OVER(PARTITION BY STU_NAME ORDER BY MARKS,SUBJECT) AS CUMMALIVE_SUM
FROM STU_EXAM
GROUP BY STU_NAME,SUBJECT,MARKS;

CHOOSE ORDER BY CLAUSE UNIQUE RECORDS

CASE STUDY: MED TABLE

USE MED _TABLE GET STATE_CODE, COMAPNY CUSTOMER BASE IN %

SELECT
STATE_CODE,
COMPANY,
COUNT(CUSTOMER_ID) AS SUBS INTO MED_BASE
FROM MED_2023
GROUP BY STATE_CODE,COMPANY
ORDER BY 1,2;

SELECT * FROM MED_BASE;

SELECT
STATE_CODE,
COMPANY,
SUBS,
SUM(SUBS) OVER(PARTITION BY STATE_CODE ORDER BY STATE_CODE) AS TOTAL_BASE,
FORMAT((CAST(SUBS AS FLOAT)/SUM(SUBS) OVER(PARTITION BY STATE_CODE ORDER BY STATE_CODE)),'P0') AS SUBS_PERCENTAGE
FROM MED_BASE
GROUP BY STATE_CODE,COMPANY,SUBS;

LAG_CALCULATIONS:

SELECT * FROM REST_DATA;

SELECT
REST_ID,
CUST_ID,
VISIT_DATE,
LAG(VISIT_DATE,1) OVER(PARTITION BY REST_ID,CUST_ID ORDER BY VISIT_DATE) AS PREVIOUS_VIST_DATE,
NUMBER_OF_PERSONS,
SPENT_AMOUNT,
LAG(SPENT_AMOUNT,1) OVER(PARTITION BY REST_ID,CUST_ID ORDER BY VISIT_DATE) AS PREVIOUS_SPENT INTO REST_SUMMARY
FROM REST_DATA;

SELECT * FROM REST_SUMMARY;

SYNTAX:

LAG(SCALAR_EXPRESSSION,OFFSET) OVER (PARTITION BY FIELDS ORDER BY FIELDS)

SCALAR EXPRESSSION: THE VALUE THAT WE ARE CONSIDERING FOR ANALYSIS
OFFSET: THE NUMBER OF ROWS BACK(DEFAULT 1)

DAYS GAP, SPENT DIFF

SELECT
REST_ID,
CUST_ID,
VISIT_DATE,
LAG(VISIT_DATE,1) OVER(PARTITION BY REST_ID, CUST_ID ORDER BY VISIT_DATE) AS PREVIOS_VISIT,
DATEDIFF(DAY,LAG(VISIT_DATE,1) OVER(PARTITION BY REST_ID, CUST_ID ORDER BY VISIT_DATE),VISIT_DATE) AS DAYS_GAP,
NUMBER_OF_PERSONS,
SPENT_AMOUNT,
LAG(SPENT_AMOUNT,1) OVER(PARTITION BY REST_ID,CUST_ID ORDER BY VISIT_DATE) AS PREVIOUYS_SPENT,
(SPENT_AMOUNT-LAG(SPENT_AMOUNT,1) OVER(PARTITION BY REST_ID,CUST_ID ORDER BY VISIT_DATE)) AS SPENT_DIFF
INTO REST_DATA_2
FROM REST_DATA;

SELECT * FROM REST_DATA_2;

USE OF ROW_NUMBER:

SELECT
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
SPENT_AMOUNT,
ROW_NUMBER() OVER(ORDER BY CUSTOMER_ID) AS ROW_NUM
FROM MED_2023;

SELECT
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
SPENT_AMOUNT,
ROW_NUMBER() OVER(ORDER BY (SELECT NULL)) AS ROW_NUM
FROM MED_2023;

CREATE AN EMPLOYEE TABLE(EMP_ID, NAME, SALARY)
FIND EMPLOYEE WHO ARE GETTING SALARY GREATER THAN THE AVG SALARY

CREATE TABLE EMPLOYEE
(EMP_ID INT,
NAME VARCHAR (20),
SALARY INT);

SELECT * FROM EMPLOYEE;

INSERT INTO EMPLOYEE VALUES(10011,'ABHI',80000);
INSERT INTO EMPLOYEE VALUES(10022,'GAURI',90000);
INSERT INTO EMPLOYEE VALUES(10033,'SID',50000);
INSERT INTO EMPLOYEE VALUES(10044,'BILL',60000);
INSERT INTO EMPLOYEE VALUES(10055,'AJAY',70000);
INSERT INTO EMPLOYEE VALUES(10066,'SAM',69000);

SELECT * FROM EMPLOYEE;

STEP 1: CREATE TEMPORY TABLES: WITH

WITH TEMP_TABLE(AVG_SALARY) AS (SELECT AVG(SALARY) FROM EMPLOYEE)
SELECT
EMP_ID,
NAME,
SALARY,
AVG_SALARY
FROM EMPLOYEE,TEMP_TABLE
WHERE EMPLOYEE.SALARY>=TEMP_TABLE.AVG_SALARY;

VIEW: VIRTUAL TABLE.

CREATE VIEW
MED_2023_SUMMARY_VIEW
AS
SELECT
STATE_CODE,
COMPANY,
GENDER,
COUNT(CUSTOMER_ID) AS SUBS,
SUM(NO_OF_TRIPS) AS VISITS,
SUM(SPENT_AMOUNT) AS TOTAL_SPENT
FROM MED_2023
GROUP BY STATE_CODE,COMPANY,GENDER;

SELECT * FROM MED_2023_SUMMARY_VIEW;

VIEW NEVER TAKES MEMORY
	1. VIEW STORES DATA AS QUERY
	2.QUERY NEVER OCCUPIES MEMORY SPACE.

STORE PROCEDURE:

SELECT
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
SPENT_AMOUNT
FROM MED_2023
WHERE COMPANY='APPOLO' AND GENDER='FEMALE' AND AGE>50 AND STATE_CODE='WA';

SELECT
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
SPENT_AMOUNT
FROM MED_2023
WHERE COMPANY='CIPLA' AND GENDER='FEMALE' AND AGE>50 AND STATE_CODE='WA';

SELECT
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
SPENT_AMOUNT
FROM MED_2023
WHERE COMPANY='GENO' AND GENDER='FEMALE' AND AGE>50 AND STATE_CODE='WA';

REPEATING PROGRAMS IN SQL ARE CALLED :REDUNDANT PROGRAMS
AUTOMATE THEM: STORE PROCEDURE

STORE PROCEDURE STEPS:
	1.DYNAMICS IN THE PROGRAM
		1.COMPANY
		2.GENDER
		3.AGE
		4.STATE_CODE
	2.CALL DYNAMIC VARIABLES OR FIELDS INTO A PARAMETER(@)

CREATE PROCEDURE SQL_MACRO1
@COMP CHAR(15),
@GEN CHAR(15),
@AG INT,
@STCD CHAR(15)
AS
BEGIN
SELECT
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
SPENT_AMOUNT
FROM MED_2023
WHERE COMPANY=@COMP AND GENDER=@GEN AND AGE>@AG AND STATE_CODE=@STCD
END;

EXEC SQL_MACRO1 'APPOLO','MALE',50,'NSW';
EXEC SQL_MACRO1 'GSK','FEMALE',40,'QLD';

CREATE PROCEDURE
NAME PARAMETERS---@NAME DATATYPE(LENGTH)
--
--
AS
BEGIN
SELECT
FIELD 1,
FIELDS2,

FROM TABLE IN DATABASE
WHERE CALL PARAMETER
END;

EXEC NAME MACRO 'FIELD1', 'FIELD2';

DROP PROCEDURE:

DROP PROC SQL_MACRO1;

--## Inserting the value by using store procedure

CREATE TABLE STORE_PROCEDURE_TABLE_1(
NAME NVARCHAR(20),
DEPARTMENT NVARCHAR(20),
SALARY DECIMAL (10,2));

SELECT * FROM STORE_PROCEDURE_TABLE_1;

CREATE PROCEDURE InsertValues_SP
    @Name NVARCHAR(50),
    @Department NVARCHAR(50),
    @Salary DECIMAL(10, 2)
AS
BEGIN
    INSERT INTO STORE_PROCEDURE_TABLE_1 (NAME, DEPARTMENT, SALARY)
    VALUES (@Name, @Department, @Salary);
END


EXEC InsertValues_SP @Name='sambit kumar jena', @Department='statistics',@Salary=23340.55;
 SELECT * FROM STORE_PROCEDURE_TABLE_1;
 
-- Update Procedure:
--This procedure updates data in a table based on a condition.

SELECT * FROM DEVOTEE_RESERACH;

CREATE PROCEDURE UPDATE_SP @NEW_JAPMALA INT, @GURUDEV VARCHAR(20)
AS 
BEGIN 
UPDATE DEVOTEE_RESERACH SET JAPMALA=@NEW_JAPMALA WHERE GURUDEV = @GURUDEV;
END

EXEC UPDATE_SP @NEW_JAPMALA=20, @GURUDEV='HEMHARI PRABHU';

SELECT * FROM DEVOTEE_RESERACH;


--Delete Procedure:
--This procedure deletes data from a table based on a condition.

INSERT INTO DEVOTEE_RESERACH VALUES('JAYPATAKA SWAMY', 'RADHA',32);
SELECT * FROM DEVOTEE_RESERACH;

CREATE PROCEDURE DELETE_SP @gurudev VARCHAR(20)
AS 
BEGIN
DELETE FROM DEVOTEE_RESERACH WHERE GURUDEV = @gurudev;
END

EXEC DELETE_SP @gurudev ='JAYPATAKA SWAMY';

SELECT * FROM DEVOTEE_RESERACH;

LOOPS:
LOOPS ARE PROGRAMMING CONCEPTS THAT ENABLES US TO DO REPEATED WORK IN THE BACKEND.

STEPS:
	1.DECLARE COUNTER AND DATATYPE
	2.SET COUNTER VALUE
	3.CONDITION

EG:

DECLARE @COUNTER INT
SET @COUNTER=1
WHILE (@COUNTER<=10)
	BEGIN
		PRINT 'THE COUNTER VALUE IS='+ CONVERT(VARCHAR,@COUNTER)
		SET @COUNTER=@COUNTER+1
	END;

EG2:

DECLARE @COUNTER INT
SET @COUNTER=1
WHILE (@COUNTER<=20)
	BEGIN
	IF @COUNTER % 2=1
	BEGIN
	SET @COUNTER=@COUNTER+1
	CONTINUE
	END
	PRINT 'THE COUNTER VALUE IS= '+ CONVERT(VARCHAR,@COUNTER)
	SET @COUNTER=@COUNTER+1
	END;

SQL FUNCTION:

4 TYPES:

1. SYSTEM FUNCTIONS(CHARINDEX, PATINDEX, SUBSTRING,,,,)
2.AGGREGATE FUNCTIONS(SUM, COUNT, MIN, MAX...)
3.TABLE VALUED FUNCTIONS
4.SCALAR FUNCTIONS

USERDEFINED: 
	1.TABLE VALUED FUNCTIONS
	2.SCALAR FUNCTIONS

1.TABLE VALUED FUNCTIONS

CREATE FUNCTION SEL_GEN(@GEN CHAR(10))
RETURNS TABLE
AS
RETURN
(SELECT
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
SPENT_AMOUNT
FROM MED_2023
WHERE GENDER=@GEN);

SELECT * FROM SEL_GEN('FEMALE');
SELECT * FROM SEL_GEN('MALE');

2.SCALAR VALUED FUNCTIONS:

SELECT 200+300 AS VALUE;

CREATE FUNCTION ADD_100(@NUM AS INT)
RETURNS DECIMAL
AS
BEGIN
RETURN(@NUM+100)
END;

SELECT [dbo].[ADD_100](1000);

SELECT
CUSTOMER_ID,
COMPANY,
GENDER,
AGE,
STATE_CODE,
SPENT_AMOUNT,
([dbo].[ADD_100](SPENT_AMOUNT)) AS NEW_SPENT
FROM MED_2023;

QUESTIONS:

1. DIFFERENCE BETWEEN WHERE AND HAVING?
2.WHAT IS CANDIDATE KEY? EG: CUST_NAME
3.WHAT IS FOREIGN KEY?(DUPLICATE, TRANSACTION TABLE)
4.WHAT IS A PRIMARY KEY?(NO NULL VALUES, UNIQUE)
5. TRANSACTION TABLE-STAFF TABLE(RELATIONSHIP MANY TO ONE)- JOIN(LEFT TABLE)
6. WHAT IS THE DIFFERENCE BETWEEN DELETE, DROP AND TRUNCATE TABLE?
7. JOIN TWO TYPES: VERTICAL AND HORIZONTAL JOINS
8. TWO TYPES OF VERTICAL JOIN(UNION  AND UNION ALL)
9. CROSS JOIN
10.WHAT IS RANK() , DENSE_RANK(), ROW_NUMBER?
11.WHAT IS ORDER OF EXECUTION?
12.WHAT IS THE DIFFERENCE CHARINDEX AND PATINDEX(_)?
13. WHAT IS THE DIFFERENCE BETWEEN PARTITION BY AND GROUP BY?
14 WHAT IS SELF JOIN?(ROW OF TABLE ARE GETTING CONNECTED ROWS OF THE SAME TABLE)


